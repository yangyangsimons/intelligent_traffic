# OptGraph 组件数据更新使用示例

## 问题解决

### 1. 支持对象格式批量传入数据 ✅

### 2. 解决图表频繁刷新闪动问题 ✅

## 使用方法

### 方式一：对象格式批量传入（推荐）

一次性传入所有指标的数据，组件会自动缓存并根据当前选中的指标显示对应数据：

```javascript
// 定义数据对象
let optimizationcompareGraph = {
  averageThroughput: {
    current: [32, 44, 25, 28, 29, 86],
    weekly: [39, 57, 30, 33, 33, 115],
    timeLabels: [
      '旺龙路与尖山路',
      '旺龙路与青山路',
      '青山路与尖山路',
      '望青路与青山路',
      '岳麓大道与旺龙路',
      '岳麓大道与麓谷大道',
    ],
  },
  carLine: {
    current: [120, 150, 80, 90, 100, 200],
    weekly: [100, 130, 70, 80, 90, 180],
    timeLabels: [
      '旺龙路与尖山路',
      '旺龙路与青山路',
      '青山路与尖山路',
      '望青路与青山路',
      '岳麓大道与旺龙路',
      '岳麓大道与麓谷大道',
    ],
  },
  delayTime: {
    current: [5.2, 6.1, 3.8, 4.2, 4.5, 8.3],
    weekly: [4.5, 5.3, 3.2, 3.8, 4.0, 7.1],
    timeLabels: [
      '旺龙路与尖山路',
      '旺龙路与青山路',
      '青山路与尖山路',
      '望青路与青山路',
      '岳麓大道与旺龙路',
      '岳麓大道与麓谷大道',
    ],
  },
}

// 发送事件更新数据
const event = new CustomEvent('optSelectChanged', {
  detail: optimizationcompareGraph,
})
window.dispatchEvent(event)
```

### 方式二：单个指标传入（兼容旧格式）

```javascript
// 方式 2a: key + data 格式
const event = new CustomEvent('optSelectChanged', {
  detail: {
    key: 'averageThroughput',
    data: {
      current: [32, 44, 25, 28, 29, 86],
      weekly: [39, 57, 30, 33, 33, 115],
      timeLabels: ['旺龙路与尖山路', '旺龙路与青山路', ...]
    }
  }
})
window.dispatchEvent(event)

// 方式 2b: 单个键值对格式（旧格式）
const event = new CustomEvent('optSelectChanged', {
  detail: {
    averageThroughput: {
      current: [32, 44, 25, 28, 29, 86],
      weekly: [39, 57, 30, 33, 33, 115],
      timeLabels: [...]
    }
  }
})
window.dispatchEvent(event)
```

## 性能优化说明

### 1. 数据对比去重

- 每次更新前会对比新旧数据，如果数据相同则跳过更新
- 避免无意义的重复渲染

### 2. 图表平滑更新

- 使用 `notMerge: false` 避免图表重新初始化
- 使用 `lazyUpdate: true` 延迟更新减少闪动
- ECharts 会智能地进行增量更新而不是完全重绘

### 3. 数据缓存机制

- 所有指标数据都会被缓存
- 切换指标时直接使用缓存，无需重新请求数据
- 适合每 5 秒频繁更新的场景

## 完整示例：定时更新场景

```javascript
// 模拟每5秒更新一次数据
setInterval(() => {
  // 生成新数据（这里用随机数模拟，实际应该从后端获取）
  const optimizationcompareGraph = {
    averageThroughput: {
      current: Array.from({ length: 6 }, () => Math.floor(Math.random() * 100)),
      weekly: Array.from({ length: 6 }, () => Math.floor(Math.random() * 120)),
      timeLabels: [
        '旺龙路与尖山路',
        '旺龙路与青山路',
        '青山路与尖山路',
        '望青路与青山路',
        '岳麓大道与旺龙路',
        '岳麓大道与麓谷大道',
      ],
    },
    carLine: {
      current: Array.from({ length: 6 }, () => Math.floor(Math.random() * 200)),
      weekly: Array.from({ length: 6 }, () => Math.floor(Math.random() * 180)),
      timeLabels: [
        '旺龙路与尖山路',
        '旺龙路与青山路',
        '青山路与尖山路',
        '望青路与青山路',
        '岳麓大道与旺龙路',
        '岳麓大道与麓谷大道',
      ],
    },
    delayTime: {
      current: Array.from({ length: 6 }, () => (Math.random() * 10).toFixed(1)),
      weekly: Array.from({ length: 6 }, () => (Math.random() * 8).toFixed(1)),
      timeLabels: [
        '旺龙路与尖山路',
        '旺龙路与青山路',
        '青山路与尖山路',
        '望青路与青山路',
        '岳麓大道与旺龙路',
        '岳麓大道与麓谷大道',
      ],
    },
  }

  // 批量更新所有指标
  const event = new CustomEvent('optSelectChanged', {
    detail: optimizationcompareGraph,
  })
  window.dispatchEvent(event)
}, 5000)
```

## 注意事项

1. **timeLabels 必须提供**：每个指标都需要提供 timeLabels 数组
2. **数据长度一致**：current、weekly、timeLabels 的长度应该保持一致
3. **数据格式**：current 和 weekly 必须是数组
4. **指标键名固定**：目前支持 `averageThroughput`、`carLine`、`delayTime` 三个指标
